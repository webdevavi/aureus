import json
import uuid
import shutil
from pathlib import Path
from datetime import datetime
from jinja2 import Environment, FileSystemLoader, select_autoescape
from playwright.async_api import async_playwright


TMP_ROOT = Path("tmp")
TEMPLATES_DIR = "templates"
OUTPUT_DIR = TMP_ROOT / "output"
DOWNLOADS_DIR = TMP_ROOT / "output"

TMP_ROOT.mkdir(exist_ok=True, parents=True)
OUTPUT_DIR.mkdir(exist_ok=True, parents=True)
DOWNLOADS_DIR.mkdir(exist_ok=True, parents=True)

env = Environment(
    loader=FileSystemLoader(str(TEMPLATES_DIR)),
    autoescape=select_autoescape(["html", "xml"]),
)


def safe_round(value, ndigits=2):
    try:
        return round(float(value), ndigits)
    except Exception:
        return value


env.filters["safe_round"] = safe_round


def render_html(report_data: dict) -> str:
    report_data["generated_on"] = datetime.now().strftime("%d %B %Y")
    return env.get_template("report.html").render(
        report_data=report_data, **report_data
    )


async def render_to_pdf(html: str, output_path: Path):
    async with async_playwright() as p:
        browser = await p.chromium.launch()
        page = await browser.new_page()
        await page.set_content(html, wait_until="load")

        await page.pdf(
            path=str(output_path),
            format="A4",
            print_background=True,
            margin={"top": "1cm", "bottom": "1cm", "left": "1cm", "right": "1cm"},
            display_header_footer=True,
            header_template="<div></div>",
            footer_template="""
                <footer style="
                    width:100%;
                    font-size:9px;
                    font-family:'Fira Sans','Helvetica Neue',Arial,sans-serif;
                    display:flex;
                    justify-content:space-between;
                    padding:0 25px;
                    border-top:1px solid #ccc;
                    box-sizing:border-box;
                    height:18px;
                    align-items:center;
                ">
                    <span style="opacity:0.8;">Generated by <b>AsyncFoundry</b> â€” Confidential</span>
                    <span style="opacity:0.8;">Page <span class='pageNumber'></span> / <span class='totalPages'></span></span>
                </footer>
            """,
        )
        await browser.close()
    return output_path


async def generate_report(extracted_json_path: str | Path) -> str:
    extracted_json_path = Path(extracted_json_path)
    if not extracted_json_path.exists():
        raise FileNotFoundError(f"Input JSON not found: {extracted_json_path}")

    job_id = uuid.uuid4().hex[:8]
    tmp_dir = TMP_ROOT / f"report_{job_id}"

    tmp_dir.mkdir(parents=True, exist_ok=True)
    pdf_path_tmp = tmp_dir / f"report_{job_id}.pdf"
    final_path = OUTPUT_DIR / f"report_{job_id}.pdf"

    try:
        with extracted_json_path.open("r", encoding="utf-8") as f:
            report_data = json.load(f)

        def trace_bad_iterables(obj, path="root"):
            if isinstance(obj, dict):
                for k, v in obj.items():
                    sub = f"{path}.{k}"
                    if callable(v):
                        print(f"Callable at {sub}: {v}")
                    elif isinstance(v, (list, dict)):
                        trace_bad_iterables(v, sub)
                    elif hasattr(v, "__iter__") and not isinstance(
                        v, (str, bytes, dict, list)
                    ):
                        print(f"Weird iterable at {sub}: {type(v)}")
            elif isinstance(obj, list):
                for i, v in enumerate(obj):
                    sub = f"{path}[{i}]"
                    if callable(v):
                        print(f"Callable at {sub}: {v}")
                    elif isinstance(v, (list, dict)):
                        trace_bad_iterables(v, sub)
                    elif hasattr(v, "__iter__") and not isinstance(
                        v, (str, bytes, dict, list)
                    ):
                        print(f"Weird iterable at {sub}: {type(v)}")

        trace_bad_iterables(report_data)

        html = render_html(report_data)
        await render_to_pdf(html, pdf_path_tmp)

        shutil.move(str(pdf_path_tmp), str(final_path))
        print(f"PDF report generated at: {final_path}")

        return str(final_path)

    except Exception as e:
        print(f"Report generation failed: {e}")
        raise

    finally:
        try:
            if tmp_dir.exists():
                shutil.rmtree(tmp_dir, ignore_errors=True)
                print(f"Cleaned up temp workspace: {tmp_dir}")
        except Exception as e:
            print(f"Cleanup failed for {tmp_dir}: {e}")
